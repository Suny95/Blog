---
title: 线程同步与锁
date: 2019-04-24 13:38:21
tags: 
	- 线程
	- 锁
	- 同步
categories:
	- 多线程
---
## 线程同步

本文参考地址: [Java多线程 (五) — 线程的同步与锁](http://cmsblogs.com/?p=1278)



线程同步是为了防止多个线程在操作统一数据时，对数据造成损坏。  
线程同步可以分为同步方法和同步代码块。都是使用synchronized关键字进行同步。

下面给出个例子来表示同步方法和同步代码块，实际功能一致
```  java
public class SyncClass {
    private int x = 0;
    //同步方法
    public synchronized void reduceA() {
        x += 1;
    }
    //同步代码块
    public void reduceB() {
        synchronized(this) {
            x += 1;
        }
    }
}
```

同步方法使用的锁是方法所在类的对象，等价于同步代码块

```java
public class SyncClass {
    private static int x;
    //静态同步方法
    public static synchronized void reduceA() {
        x += 1;
    }
    //静态同步代码块
    public static void reduceB() { 
        synchronized(SyncClass.class) {
            x += 1;
        }
    }
}
```

静态同步方法使用的锁是自身类(SyncClass.class)，等价于静态同步代码块

> ##### 关于同步，有以下几个要点：  

1. 只能同步方法，不能同步类和变量。
2. 类可以同时拥有同步方法和非同步方法；非同步方法可以被多个线程自由访问。
3. 同步损害并发性能，应尽可能缩小范围，也就是尽量使用同步代码块，而不是同步方法。

## 线程锁

+ #### 锁原理

  &emsp;&emsp;Java中每个对象都有一个内置锁。当程序运行到非静态的，由synchronized修饰的同步方法时，自动获得正在执行代码类的当前实例锁。同理，同步代码块获取锁的方式也与其一致。

  &emsp;&emsp;一个对象只有一个锁，所以当一个线程获取到该对象锁后，其他线程将无法再获取此锁，直至第一个线程释放锁。也正是这个机制，所以才可以保证同步方法可以在多线程环境下可以正确的执行期望的逻辑顺序。

> #####  关于锁，有以下几个要点：  

1. 每个对象只有一个锁，当提到同步时，应该清楚在哪个对象上同步。
2. 多个线程执行一个类中的synchronized方法，并且所有线程都使用相同的实例调用方法，那么一次只能有一个线程可以执行方法，其他线程需要进行等待，直至锁被释放。也就是说：如果一个线程在对象上获得一个锁，就不会再有其他线程可以进入该类的任意一个同步方法。
4. 线程睡眠时，所持的锁不会释放。
5. 线程可以获得多个锁。比如：在一个对象的同步方法里调用另一个对象的同步方法，则获取了两个对象的锁。

+ #### 阻塞

  &emsp;&emsp;如果一个线程在进入同步方法时，发现其锁已经背占用，则线程会被加入该对象上的等待池中，也就是被阻塞了。直至锁被释放，被阻塞线程才会再次变为就绪状态或运行状态。

> ##### 当考虑阻塞时,应关注如下几点: 

1. 调用同一个对象中非静态中同步方法的线程将彼此互斥。如果是不同对象，则每个线程有自己对象的锁，线程间无互斥。
2. 调用同一个类中的静态同步方法线程将彼此互斥。它们都是锁定在相同的Class上。
3. 静态同步方法和非静态同步方法永远不会彼此互斥，因为静态方法锁定在Class上，非静态方法锁定在该类的对象上。
4. 对于同步代码块，要清楚什么对象已经锁定。在同一个对象上进行同步的线程将彼此互斥，反之不会互斥。

## 线程同步总结

1. 线程同步的目的是为了保护多个线程访问同一数据时对数据的破坏。
2. 线程同步方法是通过锁来实现的，每个对象都有且仅有一个锁。线程一旦获取了该锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。
3. 静态同步方法与非静态同步方法彼此互不干预。
4. 当一个线程获取到锁时，其他准备获取锁的线程将被阻塞。